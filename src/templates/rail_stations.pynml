<!--! CABBAGE spritesets_legacy -->
<tal:include metal:use-macro="load: spritesets_legacy.pynml" />

<tal:include metal:use-macro="load: spritelayouts_rail_station.pynml" />

<tal:stations repeat="station stations">

    switch(FEAT_STATIONS, SELF, ${station.id}_switch_select_sprite_layout, ${len(station.layout)} * (platform_position_from_start(PLATFORM_SAME_SECTION) % 2)) {
        return;
    }

    switch(FEAT_STATIONS, SELF, ${station.id}_switch_prepare_layout, [
        <tal:custom_sprite_indexes repeat="custom_sprite_index_struct station.custom_sprite_index_structs">
            // ${custom_sprite_index_struct[2]}
            STORE_TEMP(${custom_sprite_index_struct[0]}, ${custom_sprite_index_struct[1]}),
        </tal:custom_sprite_indexes>
        <!--! snow sprite is partially provided, but incomplete, so nerf it by forcing the register to 1 (hide snow) -->
        STORE_TEMP(1, ${graphics_temp_storage.var_hide_building_snow}),
        STORE_TEMP(0, ${graphics_temp_storage.var_hide_cargo}),
        STORE_TEMP(hasbit(rail_continuation, 1), ${graphics_temp_storage.var_hide_buffer_stop_ne_and_nw}),
        STORE_TEMP(hasbit(rail_continuation, 0), ${graphics_temp_storage.var_hide_buffer_stop_se_and_sw}),
        STORE_TEMP(${station.palette}, ${graphics_temp_storage.var_palette_building_recolour}),
        ]) {
        return;
    }
    <!--! !! CABBAGE there could be prepare_layout_common or so, which both of these chain to ?? -->
    switch(FEAT_STATIONS, SELF, ${station.id}_switch_purchase_prepare_layout, [
        <tal:custom_sprite_indexes repeat="custom_sprite_index_struct station.custom_sprite_index_structs">
            // ${custom_sprite_index_struct[2]}
            STORE_TEMP(${custom_sprite_index_struct[0]}, ${custom_sprite_index_struct[1]}),
        </tal:custom_sprite_indexes>
        <!--! snow sprite is partially provided, but incomplete, so nerf it by forcing the register to 1 (hide snow) -->
        STORE_TEMP(1, ${graphics_temp_storage.var_hide_building_snow}),
        STORE_TEMP(1, ${graphics_temp_storage.var_hide_cargo}),
        STORE_TEMP(1, ${graphics_temp_storage.var_hide_buffer_stop_ne_and_nw}),
        STORE_TEMP(1, ${graphics_temp_storage.var_hide_buffer_stop_se_and_sw}),
        STORE_TEMP(${station.palette}, ${graphics_temp_storage.var_palette_building_recolour}),
        ]) {
        return;
    }

    item(FEAT_STATIONS, ${station.id}, ${station.numeric_id}) {
        property {
            class:                  "${station.station_class.class_id}";
    		classname:              string(${station.classname_string_id});
            name:                   string(${station.name_string_id});
            draw_pylon_tiles:       ${station.draw_pylon_tiles};
            hide_wire_tiles:        ${station.hide_wire_tiles};
            non_traversable_tiles:  ${station.non_traversable_tiles};
        }
        graphics {
            sprite_layouts:          ${station.spritelayouts_as_nml_array};
            select_sprite_layout:    ${station.id}_switch_select_sprite_layout;
            prepare_layout:          ${station.id}_switch_prepare_layout();
            purchase_prepare_layout: ${station.id}_switch_purchase_prepare_layout();
            <tal:visible_cargo condition="facility_type.visible_cargo">
                <tal:cargos repeat="cargo_label cargo_manager.cargo_labels">
                    ${cargo_label}:  ${cargo_manager.get_spriteset_id_by_cargo_label(cargo_label)};
                </tal:cargos>
            </tal:visible_cargo>
            <!--! default result for DEFAULT() - we want empty cargo sprites in that case -->
            ${cargo_manager.get_spriteset_id_by_cargo_label("NULL")};
        }
    }
</tal:stations>

