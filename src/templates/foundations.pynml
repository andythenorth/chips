<tal:feature_type repeat="feature_type ['FEAT_OBJECTS', 'FEAT_ROADSTOPS', 'FEAT_STATIONS']">
    <!--! !!!!!!!! CABBAGE as of October 2023 nearby_tile_slope(0,0) is used rather than tile_slope
         as the implementation of slopes was missing from road stop var 0x42, which tile_slope depends on
    -->

    <!--! can't check for water directly on the object tile, as it's not reliable on coasts, so offset to appropriate nearby tiles and check for water class
          this has to be slope-specific to avoid annoying corner cases
          we also check tile height as we only want water at height level 0
    -->
    <tal:water_checks repeat="tile_offset_mapping foundations.tile_offset_mapping_for_nml_water_check()">
        switch(${feature_type}, SELF, ${feature_type}_switch_initialise_foundations_check_water_${tile_offset_mapping["slope_name"]},
        [
            <tal:tile_offsets repeat="tile_offset tile_offset_mapping['offsets']">
                (
                    (nearby_tile_water_class(${tile_offset[0]}, ${tile_offset[1]}) != WATER_CLASS_NONE)
                    &&
                    (nearby_tile_height(${tile_offset[0]}, ${tile_offset[1]}) == 0)
                )
                | <!--! bitwise OR seems to be needed here -->
            </tal:tile_offsets>
            0 <!--! 0 to OR with the last | inserted by the repeat -->
        ]) {
            return;
        }
    </tal:water_checks>
    <!--! check nearby tiles for water, this has to be slope-specific to avoid annoying corner cases -->
    switch(${feature_type}, SELF, ${feature_type}_switch_initialise_foundations_nearby_tile_is_water, nearby_tile_slope(0,0)) {
        <tal:foundation_slope_mapping repeat="slope_mapping foundations.custom_foundation_mapping_for_nml_slope_check()">
            ${slope_mapping["slope_name"]}: ${feature_type}_switch_initialise_foundations_check_water_${slope_mapping["slope_name"]}();
        </tal:foundation_slope_mapping>
        return 0; <!--! default case is 'not water' -->
    }

    <!--! store the spriteset indexes for custom foundations to use next to water, these are multiplied by a bool for 'tile is next to water', with index 0 being a blank sprite -->
    switch(${feature_type}, SELF, ${feature_type}_switch_initialise_foundations_store_custom_spriteset_numbers, sw_face, se_face, [
            STORE_TEMP(
                sw_face * LOAD_TEMP(${graphics_temp_storage.var_foundations_tile_has_water_nearby}),
                ${graphics_temp_storage.var_custom_foundation_sw_face}
            ),
            STORE_TEMP(
                se_face * LOAD_TEMP(${graphics_temp_storage.var_foundations_tile_has_water_nearby}),
                ${graphics_temp_storage.var_custom_foundation_se_face}
            ),
        ]) {
        return;
    }
    <tal:not_rail_stations condition="feature_type != 'FEAT_STATIONS'">
        switch(${feature_type}, SELF, ${feature_type}_switch_initialise_custom_foundation_spriteset_numbers, nearby_tile_slope(0,0)) {
            <tal:foundation_slope_mapping repeat="slope_mapping foundations.custom_foundation_mapping_for_nml_slope_check()">
                ${slope_mapping["slope_name"]}: ${feature_type}_switch_initialise_foundations_store_custom_spriteset_numbers(${slope_mapping["sw_face"]}, ${slope_mapping["se_face"]});
            </tal:foundation_slope_mapping>
            return;
        }
    </tal:not_rail_stations>
    <tal:rail_stations_only condition="feature_type == 'FEAT_STATIONS'">
        <!--! rail stations have to be special cased as the API is archaic -->
        switch(FEAT_STATIONS, SELF, FEAT_STATIONS_switch_initialise_custom_foundation_spriteset_numbersXY, nearby_tile_slope(0,0)) {
            <tal:foundation_slope_mapping repeat="slope_mapping foundations.custom_foundation_mapping_for_nml_slope_check()">
                ${slope_mapping["slope_name"]}: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(${slope_mapping["sw_face"]}, ${slope_mapping["se_face"]});
            </tal:foundation_slope_mapping>
            return;
        }
        switch(FEAT_STATIONS, SELF, FEAT_STATIONS_switch_initialise_custom_foundation_spriteset_numbersYX, nearby_tile_slope(0,0)) {
            <!--! rail stations transpose the results of nearby_tile_slope depending on their XY / YX orientation, so we have to handle that specifically -->
            <!--!
            <tal:foundation_slope_mapping repeat="slope_mapping foundations.custom_foundation_mapping_for_nml_slope_check()">
                ${slope_mapping["slope_name"]}: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(${slope_mapping["sw_face"]}, ${slope_mapping["se_face"]});
            </tal:foundation_slope_mapping>-->
                SLOPE_FLAT: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(1, 2);
                SLOPE_W: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(1, 4);
                SLOPE_S: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(1, 2);
                SLOPE_E: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(3, 2);
                SLOPE_N: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(5, 6);
                SLOPE_NW: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(1, 4);
                SLOPE_SW: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(5, 0);
                SLOPE_SE: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(0, 6);
                SLOPE_NE: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(3, 2);
                SLOPE_EW: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(3, 4);
                SLOPE_NS: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(5, 6);
                SLOPE_NWS: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(5, 0);
                SLOPE_WSE: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(0, 0);
                SLOPE_SEN: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(0, 6);
                SLOPE_ENW: FEAT_STATIONS_switch_initialise_foundations_store_custom_spriteset_numbers(3, 4);
            return;
        }
        switch(FEAT_STATIONS, SELF, FEAT_STATIONS_switch_initialise_custom_foundation_spriteset_numbers, tile_type&1) {
            <!--! rail stations transpose the results of nearby_tile_slope depending on their XY / YX orientation, so we have to handle that specifically
                  this relies on tile_type being odd or even depending on orientation -->
            0: FEAT_STATIONS_switch_initialise_custom_foundation_spriteset_numbersXY;
            return FEAT_STATIONS_switch_initialise_custom_foundation_spriteset_numbersYX;
        }
    </tal:rail_stations_only>

    switch(${feature_type}, SELF, ${feature_type}_switch_initialise_foundations_graphics, [
            STORE_TEMP(${feature_type}_switch_initialise_foundations_nearby_tile_is_water(), ${graphics_temp_storage.var_foundations_tile_has_water_nearby}),
            ${feature_type}_switch_initialise_custom_foundation_spriteset_numbers(),
        ]) {
        return;
    }
    switch(${feature_type}, SELF, ${feature_type}_switch_initialise_foundations_purchase, [
            STORE_TEMP(0, ${graphics_temp_storage.var_foundations_tile_has_water_nearby}),
            ${feature_type}_switch_initialise_foundations_store_custom_spriteset_numbers(0, 0),
        ]) {
        return;
    }

    switch(${feature_type}, SELF, switch_initialise_foundations_${feature_type}, context_is_purchase, context_is_purchase) {
        1: ${feature_type}_switch_initialise_foundations_purchase;
        ${feature_type}_switch_initialise_foundations_graphics;
    }
</tal:feature_type>
